//! This module contains an example of code generated by the macro. **IT IS NOT MEANT
//! TO BE USED OUTSIDE THIS CRATE**.
//!
//! If you would like to see what the actual code looks like, click the `src` button
//! located top-right. If you are not interested in the code and simply want to
//! browse the functionality exposed to you, click on the `ExampleFlags` struct and
//! read on.

use __core::cmp::Ordering;
use __core::hash::{Hash, Hasher};
use __core::fmt::{Debug, Formatter, Binary, Octal, LowerHex, UpperHex};
use __core::ops::{BitOr, BitOrAssign, BitXor, BitXorAssign, BitAnd, BitAndAssign,
                    Sub, SubAssign, Not};
use __core::iter::FromIterator;
use __core::fmt;

/// This is the struct that the `bitflags!` macro generates.
///
/// The particular one in this example was generated from the following macro
/// invocation:
///
/// ```ignore
/// bitflags! {
///     pub struct ExampleFlags: u32 {
///         const FLAG_A       = 0b00000001;
///         const FLAG_B       = 0b00000010;
///         const FLAG_C       = 0b00000100;
///         const FLAG_ABC     = FLAG_A.bits
///                            | FLAG_B.bits
///                            | FLAG_C.bits;
///     }
/// }
/// ```
#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
pub struct ExampleFlags {
    /// This field will **not be public** in the real thing. It is public here so
    /// that it shows up in the docs for this example.
    pub bits: u32,
}

pub const FLAG_A: ExampleFlags = ExampleFlags { bits: 1 };
pub const FLAG_B: ExampleFlags = ExampleFlags { bits: 2 };
pub const FLAG_C: ExampleFlags = ExampleFlags { bits: 4 };
pub const FLAG_ABC: ExampleFlags =
    ExampleFlags { bits: FLAG_A.bits | FLAG_B.bits | FLAG_C.bits };

impl Debug for ExampleFlags {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {

        #[allow(non_snake_case)]
        trait BitFlags {
            fn FLAG_A(&self) -> bool { false }
            fn FLAG_B(&self) -> bool { false }
            fn FLAG_C(&self) -> bool { false }
            fn FLAG_ABC(&self) -> bool { false }
        }

        impl BitFlags for ExampleFlags {
            fn FLAG_A(&self) -> bool {
                self.bits & FLAG_A.bits == FLAG_A.bits
            }

            fn FLAG_B(&self) -> bool {
                self.bits & FLAG_B.bits == FLAG_B.bits
            }

            fn FLAG_C(&self) -> bool {
                self.bits & FLAG_C.bits == FLAG_C.bits
            }

            fn FLAG_ABC(&self) -> bool {
                self.bits & FLAG_ABC.bits == FLAG_ABC.bits
            }
        }

        let mut first = true;
        if <ExampleFlags as BitFlags>::FLAG_A(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("FLAG_A")?;
        }

        if <ExampleFlags as BitFlags>::FLAG_B(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("FLAG_B")?;
        }

        if <ExampleFlags as BitFlags>::FLAG_C(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("FLAG_C")?;
        }

        if <ExampleFlags as BitFlags>::FLAG_ABC(self) {
            if !first {
                f.write_str(" | ")?;
            }
            first = false;
            f.write_str("FLAG_ABC")?;
        }

        if first {
            f.write_str("(empty)")?;
        }

        Ok(())
    }
}

impl Binary for ExampleFlags {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        Binary::fmt(&self.bits, f)
    }
}
impl Octal for ExampleFlags {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        Octal::fmt(&self.bits, f)
    }
}

impl LowerHex for ExampleFlags {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        LowerHex::fmt(&self.bits, f)
    }
}

impl UpperHex for ExampleFlags {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        UpperHex::fmt(&self.bits, f)
    }
}

#[allow(dead_code)]
impl ExampleFlags {
    /// Returns an empty set of flags.
    #[inline]
    pub fn empty() -> ExampleFlags { ExampleFlags { bits: 0 } }

    /// Returns the set containing all flags.
    #[inline]
    pub fn all() -> ExampleFlags {
        #[allow(non_snake_case)]
        trait BitFlags {
            fn FLAG_A() -> u32 { 0 }
            fn FLAG_B() -> u32 { 0 }
            fn FLAG_C() -> u32 { 0 }
            fn FLAG_ABC() -> u32 { 0 }
        }

        impl BitFlags for ExampleFlags {
            fn FLAG_A() -> u32 { FLAG_A.bits }
            fn FLAG_B() -> u32 { FLAG_B.bits }
            fn FLAG_C() -> u32 { FLAG_C.bits }
            fn FLAG_ABC() -> u32 { FLAG_ABC.bits }
        }

        ExampleFlags { bits:
                                <ExampleFlags as BitFlags>::FLAG_A()   |
                                <ExampleFlags as BitFlags>::FLAG_B()   |
                                <ExampleFlags as BitFlags>::FLAG_C()   |
                                <ExampleFlags as BitFlags>::FLAG_ABC() }
    }

    /// Returns the raw value of the flags currently stored.
    #[inline]
    pub fn bits(&self) -> u32 { self.bits }

    /// Convert from underlying bit representation, unless that representation
    /// contains bits that do not correspond to a flag.
    #[inline]
    pub fn from_bits(bits: u32) -> Option<ExampleFlags> {
        if (bits & !ExampleFlags::all().bits()) == 0 {
            Some(ExampleFlags { bits: bits })
        } else { None }
    }

    /// Convert from underlying bit representation, dropping any bits that
    /// do not correspond to flags.
    #[inline]
    pub fn from_bits_truncate(bits: u32) -> ExampleFlags {
        ExampleFlags { bits: bits } & ExampleFlags::all()
    }

    /// Returns `true` if no flags are currently stored.
    #[inline]
    pub fn is_empty(&self) -> bool { *self == ExampleFlags::empty() }

    /// Returns `true` if all flags are currently set.
    #[inline]
    pub fn is_all(&self) -> bool { *self == ExampleFlags::all() }

    /// Returns `true` if there are flags common to both `self` and `other`.
    #[inline]
    pub fn intersects(&self, other: ExampleFlags) -> bool {
        !(*self & other).is_empty()
    }

    /// Returns `true` all of the flags in `other` are contained within `self`.
    #[inline]
    pub fn contains(&self, other: ExampleFlags) -> bool {
        (*self & other) == other
    }

    /// Inserts the specified flags in-place.
    #[inline]
    pub fn insert(&mut self, other: ExampleFlags) {
        self.bits |= other.bits;
    }

    /// Removes the specified flags in-place.
    #[inline]
    pub fn remove(&mut self, other: ExampleFlags) {
        self.bits &= !other.bits;
    }

    /// Toggles the specified flags in-place.
    #[inline]
    pub fn toggle(&mut self, other: ExampleFlags) {
        self.bits ^= other.bits;
    }

    /// Inserts or removes the specified flags depending on the passed value.
    #[inline]
    pub fn set(&mut self, other: ExampleFlags, value: bool) {
        if value { self.insert(other); } else { self.remove(other); }
    }
}

impl BitOr for ExampleFlags {
    type Output = ExampleFlags;

    /// Returns the union of the two sets of flags.
    #[inline]
    fn bitor(self, other: ExampleFlags) -> ExampleFlags {
        ExampleFlags { bits: self.bits | other.bits }
    }
}

impl BitOrAssign for ExampleFlags {
    /// Adds the set of flags.
    #[inline]
    fn bitor_assign(&mut self, other: ExampleFlags) {
        self.bits |= other.bits;
    }
}

impl BitXor for ExampleFlags {
    type Output = ExampleFlags;

    /// Returns the left flags, but with all the right flags toggled.
    #[inline]
    fn bitxor(self, other: ExampleFlags) -> ExampleFlags {
        ExampleFlags { bits: self.bits ^ other.bits }
    }
}

impl BitXorAssign for ExampleFlags {
    /// Toggles the set of flags.
    #[inline]
    fn bitxor_assign(&mut self, other: ExampleFlags) {
        self.bits ^= other.bits;
    }
}

impl BitAnd for ExampleFlags {
    type Output = ExampleFlags;

    /// Returns the intersection between the two sets of flags.
    #[inline]
    fn bitand(self, other: ExampleFlags) -> ExampleFlags {
        ExampleFlags { bits: self.bits & other.bits }
    }
}

impl BitAndAssign for ExampleFlags {
    /// Disables all flags disabled in the set.
    #[inline]
    fn bitand_assign(&mut self, other: ExampleFlags) {
        self.bits &= other.bits;
    }
}

impl Sub for ExampleFlags {
    type Output = ExampleFlags;

    /// Returns the set difference of the two sets of flags.
    #[inline]
    fn sub(self, other: ExampleFlags) -> ExampleFlags {
        ExampleFlags { bits: self.bits & !other.bits }
    }
}

impl SubAssign for ExampleFlags {
    /// Disabled all flags enabled in the set.
    #[inline]
    fn sub_assign(&mut self, other: ExampleFlags) {
        self.bits &= !other.bits;
    }
}

impl Not for ExampleFlags {
    type Output = ExampleFlags;

    /// Returns the complement of this set of flags.
    #[inline]
    fn not(self) -> ExampleFlags {
        ExampleFlags { bits: !self.bits } & ExampleFlags::all()
    }
}

impl Extend<ExampleFlags> for ExampleFlags {
    fn extend<T: IntoIterator<Item = ExampleFlags>>(&mut self, iterator: T) {
        for item in iterator { self.insert(item) }
    }
}

impl FromIterator<ExampleFlags> for ExampleFlags {
    fn from_iter<T: IntoIterator<Item = ExampleFlags>>(iterator: T) -> ExampleFlags {
        let mut result = Self::empty();
        result.extend(iterator);
        result
    }
}
